Please comment.

```java
User user = this.userRepository.findByEmail(email).orElse(null);
if (user == null) {
    user = new User();
    Company company = this.companyRepository.findByName(companyName).orElse(null);
    if (company == null) {
        company = new Company();
        company.setName(companyName);
        //Save Company
        log.info("Adding Company");
        log.info(this.mapper.valueToTree(company).toPrettyString());
        company = this.companyRepository.save(company);
    }
    user.setEmail(email);
    user.setFullName(name);
    user.setCompany(company);
    user.setRoleId(null);
    user = this.userRepository.save(user);
}
```

This code excerpt constructs values and updates repositories with the same
approach of mutating values, which in the case of object creation is not type 
safe: for example, we can accidentally forget to set the email value for the
user and end up with a "user" that was not properly constructed. Value
construction can be done in an type safe manner by writing constructors that
take as arguments the data required, such as 

```java
public User createUser(String email, String fullName, Optional<RoleId> roleId, 
   Company company) { 
   this.email = email;
   this.fullName = fullName;
   //...
}

public Company createUser(String email, String fullName, Optional<RoleId> roleId, 
   Company company) { 
   //... 
}
```

This would give us a higher type safety since the compiler would not allow us to
create a user without passing the email argument to the constructor function.

Since we don't need to mutate the values anymore to construct them (like
`user.setEmail(email)`) we can make values immutable. Immutability makes easier
to reason about the program:Â the same expression means the same thing at
different parts of the code, we don't need to worry about values changing.

Repositories update necessarily entails mutating something. We can still benefit
from an immutable and type safe functional approach with effectful code using a
type like ZIO.
